<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mtspec API &mdash; mtspec 0.3.x documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3.x',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="mtspec 0.3.x documentation" href="index.html" />
    <link rel="next" title="mtspec Utilities" href="util.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="util.html" title="mtspec Utilities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mtspec 0.3.x documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mtspec-api">
<h1>mtspec API<a class="headerlink" href="#mtspec-api" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-mtspec.multitaper"></span><p>Main functions of mtspec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">copyright:</th><td class="field-body">Lion Krischer (<a class="reference external" href="mailto:krischer&#37;&#52;&#48;geophysik&#46;uni-muenchen&#46;de">krischer<span>&#64;</span>geophysik<span>&#46;</span>uni-muenchen<span>&#46;</span>de</a>) and
Moritz Beyreuther, 2010-2015</td>
</tr>
<tr class="field-even field"><th class="field-name">license:</th><td class="field-body">GNU General Public License, Version 3
(<a class="reference external" href="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</a>)</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="mtspec.multitaper.dpss">
<tt class="descclassname">mtspec.multitaper.</tt><tt class="descname">dpss</tt><big>(</big><em>npts</em>, <em>fw</em>, <em>number_of_tapers</em>, <em>auto_spline=True</em>, <em>npts_max=None</em><big>)</big><a class="reference internal" href="_modules/mtspec/multitaper.html#dpss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mtspec.multitaper.dpss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates DPSS also known as Slepian sequences or Slepian tapers.</p>
<p>Calculation of the DPSS (Discrete Prolate Spheroidal Sequences) also knows
as the Slepian sequences, and the correspondent eigenvalues. Also, the (1 -
eigenvalue) terms are calculated.</p>
<p>Wraps the <tt class="docutils literal"><span class="pre">dpss()</span></tt> subroutine from the Fortran library.</p>
<p>By default this routine will use spline interpolation if sequences with
more than 200000 samples are requested.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tapers are the eigenvectors of the tridiagonal matrix sigma(i, j)
[see Slepian(1978) eq 14 and 25]. They are also the eigenvectors of
the Toeplitz matrix eq. 18.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>npts</strong> (<em>int</em>) &#8211; The number of points in the series</li>
<li><strong>fw</strong> (<em>float</em>) &#8211; The time-bandwidth product (number of Rayleigh bins)</li>
<li><strong>number_of_tapers</strong> (<em>int</em>) &#8211; The desired number of tapers</li>
<li><strong>auto_spline</strong> (<em>bool</em>) &#8211; Whether or not to automatically use spline
interpolation with <tt class="docutils literal"><span class="pre">npts</span></tt> &gt; 200000.</li>
<li><strong>npts_max</strong> (<em>None or int</em>) &#8211; The number of actual points to calculate the dpss. If this
number is smaller than npts spline interpolation will be performed,
regardless of auto_spline.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="docutils literal"><span class="pre">(v,</span> <span class="pre">lambda,</span> <span class="pre">theta)</span></tt> with
<tt class="docutils literal"><span class="pre">v(npts,</span> <span class="pre">number_of_tapers)</span></tt> the eigenvectors (tapers), <tt class="docutils literal"><span class="pre">lambda</span></tt> the
eigenvalues of the <tt class="docutils literal"><span class="pre">v</span></tt>&#8216;s and <tt class="docutils literal"><span class="pre">theta</span></tt> the 1 - <tt class="docutils literal"><span class="pre">lambda</span></tt>
(energy outside the bandwidth) values.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mtspec</span> <span class="kn">import</span> <span class="n">dpss</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tapers</span><span class="p">,</span> <span class="n">lamb</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">dpss</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tapers</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mtspec.multitaper.mt_coherence">
<tt class="descclassname">mtspec.multitaper.</tt><tt class="descname">mt_coherence</tt><big>(</big><em>df</em>, <em>xi</em>, <em>xj</em>, <em>tbp</em>, <em>kspec</em>, <em>nf</em>, <em>p</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/mtspec/multitaper.html#mt_coherence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mtspec.multitaper.mt_coherence" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the coherence spectrum from the yk&#8217;s and the
weights of the usual multitaper spectrum estimation.
Note this code uses the real(4) multitaper code.</p>
<p>INPUT</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>df</strong> &#8211; float; sampling rate of time series</li>
<li><strong>xi</strong> &#8211; numpy.ndarray; data for first series</li>
<li><strong>xj</strong> &#8211; numpy.ndarray; data for second series</li>
<li><strong>tbp</strong> &#8211; float; the time-bandwidth product</li>
<li><strong>kspec</strong> &#8211; integer; number of tapers to use</li>
<li><strong>nf</strong> &#8211; integer; number of freq points in spectrum</li>
<li><strong>p</strong> &#8211; float; confidence for null hypothesis test, e.g. .95</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>OPTIONAL INPUT</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>iadapt</strong> &#8211; integer 0 - adaptive, 1 - constant weights
default adapt = 1</td>
</tr>
</tbody>
</table>
<p>OPTIONAL OUTPUTS, the outputs are returned as dictionary, with keys as
specified below and values as numpy.ndarrays. In order to activate the
output set the corresponding kwarg in the argument list, e.g.
<tt class="docutils literal"><span class="pre">mt_coherence(df,</span> <span class="pre">xi,</span> <span class="pre">xj,</span> <span class="pre">tbp,</span> <span class="pre">kspec,</span> <span class="pre">nf,</span> <span class="pre">p,</span> <span class="pre">freq=True,</span> <span class="pre">cohe=True)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>freq</strong> &#8211; the frequency bins</li>
<li><strong>cohe</strong> &#8211; coherence of the two series (0 - 1)</li>
<li><strong>phase</strong> &#8211; the phase at each frequency</li>
<li><strong>speci</strong> &#8211; spectrum of first series</li>
<li><strong>specj</strong> &#8211; spectrum of second series</li>
<li><strong>conf</strong> &#8211; p confidence value for each freq.</li>
<li><strong>cohe_ci</strong> &#8211; 95% bounds on coherence (not larger than 1)</li>
<li><strong>phase_ci</strong> &#8211; 95% bounds on phase estimates</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If confidence intervals are requested, then both phase and
cohe variables need to be requested as well.</p>
</dd></dl>

<dl class="function">
<dt id="mtspec.multitaper.mtspec">
<tt class="descclassname">mtspec.multitaper.</tt><tt class="descname">mtspec</tt><big>(</big><em>data</em>, <em>delta</em>, <em>time_bandwidth</em>, <em>nfft=None</em>, <em>number_of_tapers=None</em>, <em>quadratic=False</em>, <em>adaptive=True</em>, <em>verbose=False</em>, <em>optional_output=False</em>, <em>statistics=False</em>, <em>rshape=False</em>, <em>fcrit=False</em><big>)</big><a class="reference internal" href="_modules/mtspec/multitaper.html#mtspec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mtspec.multitaper.mtspec" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method for the mtspec subroutine in the library by German A.
Prieto.</p>
<p>This method estimates the adaptive weighted multitaper spectrum, as in
Thomson 1982.  This is done by estimating the DPSS (discrete prolate
spheroidal sequences), multiplying each of the tapers with the data series,
take the FFT, and using the adaptive scheme for a better estimation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>
Array with the data.</li>
<li><strong>delta</strong> &#8211; float
Sample spacing of the data.</li>
<li><strong>time_bandwidth</strong> &#8211; float
Time-bandwidth product. Common values are 2, 3, 4 and numbers in
between.</li>
<li><strong>nfft</strong> &#8211; int
Number of points for fft. If nfft == None, no zero padding
will be applied before the fft</li>
<li><strong>number_of_tapers</strong> &#8211; integer, optional
Number of tapers to use. Defaults to int(2*time_bandwidth) - 1. This
is maximum senseful amount. More tapers will have no great influence
on the final spectrum but increase the calculation time. Use fewer
tapers for a faster calculation.</li>
<li><strong>quadratic</strong> &#8211; bool, optional
Whether or not to caluclate a quadratic multitaper. Will only work
if nfft is False or equal to the sample count. The nfft parameter
will overwrite the quadratic paramter. Defaults to False.</li>
<li><strong>adaptive</strong> &#8211; bool, optional
Whether to use adaptive or constant weighting of the eigenspectra.
Defaults to True(adaptive).</li>
<li><strong>verbose</strong> &#8211; bool, optional
Passed to the fortran library. Defaults to False.</li>
<li><strong>optional_output</strong> &#8211; bool, optional
Calculates and returns additional output parameters. See the notes in
the docstring for further details.</li>
<li><strong>statistics</strong> &#8211; bool, optional
Calculates and returns statistics. See the notes in the docstring for
further details.</li>
<li><strong>rshape</strong> &#8211; integer/None, optional
Determines whether or not to perform the F-test for lines. If rshape
is 1 or 2, then don&#8217;t put the lines back. If rshape is 2 only check
around 60 Hz. See the fortran source code for more informations.
Defaults to None (do not perform the F-test).</li>
<li><strong>fcrit</strong> &#8211; float/None, optional
The threshold probability for the F-test. If none is given, the mtspec
library calculates a default value. See the fortran source code for
details. Defaults to None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Returns a list with <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>. See the note
below.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method will at return at least two arrays: The calculated spectrum
and the corresponding frequencies.  If optional_output is true it will
also return (in the given order) (multidimensional) arrays containing
the eigenspectra, the corresponding eigencoefficients and an array
containing the weights for each eigenspectra normalized so that the sum
of squares over the eigenspectra is one.  If statistics is True is will
also return (in the given order) (multidimensional) arrays containing
the jackknife 5% and 95% confidence intervals, the F statistics for
single line and the number of degrees of freedom for each frequency
bin.  If both optional_output and statistics are true, the
optional_outputs will be returned before the statistics.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="mtspec.multitaper.sine_psd">
<tt class="descclassname">mtspec.multitaper.</tt><tt class="descname">sine_psd</tt><big>(</big><em>data</em>, <em>delta</em>, <em>number_of_tapers=None</em>, <em>number_of_iterations=2</em>, <em>degree_of_smoothing=1.0</em>, <em>statistics=False</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="_modules/mtspec/multitaper.html#sine_psd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mtspec.multitaper.sine_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method for the sine_psd subroutine in the library by German A.
Prieto.</p>
<p>The subroutine is in charge of estimating the adaptive sine multitaper as
in Riedel and Sidorenko (1995).
This is done by performing a MSE adaptive estimation. First a pilot
spectral estimate is used, and S&#8221; is estimated, in order to get te number
of tapers to use, using (13) of Riedel and Sidorenko for a min square error
spectrum.
Unlike the prolate spheroidal multitapers, the sine multitaper adaptive
process introduces a variable resolution and error in the frequency domain.
Complete error information is contained in the output variables as the
corridor of 1-standard-deviation errors, and in the number of tapers used
at each frequency.  The errors are estimated in the simplest way, from the
number of degrees of freedom (two per taper), not by jack-knifing. The
frequency resolution is found from K*fN/Nf where fN is the Nyquist
frequency and Nf is the number of frequencies estimated.  The adaptive
process used is as follows. A quadratic fit to the log PSD within an
adaptively determined frequency band is used to find an estimate of the
local second derivative of the spectrum. This is used in an equation like R
&amp; S (13) for the MSE taper number, with the difference that a parabolic
weighting is applied with increasing taper order. Because the FFTs of the
tapered series can be found by resampling the FFT of the original time
series (doubled in length and padded with zeros) only one FFT is required
per series, no matter how many tapers are used. This makes the program
fast. Compared with the Thomson multitaper programs, this code is not only
fast but simple and short. The spectra associated with the sine tapers are
weighted before averaging with a parabolically varying weight. The
expression for the optimal number of tapers given by R &amp; S must be modified
since it gives an unbounded result near points where S&#8221; vanishes, which
happens at many points in most spectra. This program restricts the rate of
growth of the number of tapers so that a neighboring covering interval
estimate is never completely contained in the next such interval.</p>
<p>This method SHOULD not be used for sharp cutoffs or deep valleys, or small
sample sizes. Instead use Thomson multitaper in mtspec in this same
library.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>
Array with the data.</li>
<li><strong>delta</strong> &#8211; float
Sample spacing of the data.</li>
<li><strong>number_of_tapers</strong> &#8211; integer/None, optional
Number of tapers to use. If none is given, the library will perform an
adaptive taper estimation with a varying number of tapers for each
frequency. Defaults to None.</li>
<li><strong>number_of_iterations</strong> &#8211; integer, optional
Number of iterations to perform. Values less than 2 will be set to 2.
Defaults to 2.</li>
<li><strong>degree_of_smoothing</strong> &#8211; float, optional
Degree of smoothing. Defaults to 1.0.</li>
<li><strong>statistics</strong> &#8211; bool, optional
Calculates and returns statistics. See the notes in the docstring for
further details.</li>
<li><strong>verbose</strong> &#8211; bool, optional
Passed to the fortran library. Defaults to False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Returns a list with <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>. See the note below
for details.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method will at return at least two arrays: The calculated
spectrum and the corresponding frequencies.  If statistics is True
is will also return (in the given order) (multidimensional) arrays
containing the 1-std errors (a simple dof estimate) and the number
of tapers used for each frequency point.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="mtspec.multitaper.wigner_ville_spectrum">
<tt class="descclassname">mtspec.multitaper.</tt><tt class="descname">wigner_ville_spectrum</tt><big>(</big><em>data</em>, <em>delta</em>, <em>time_bandwidth=3.5</em>, <em>number_of_tapers=None</em>, <em>smoothing_filter=None</em>, <em>filter_width=100</em>, <em>frequency_divider=1</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="_modules/mtspec/multitaper.html#wigner_ville_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mtspec.multitaper.wigner_ville_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method of the modified wv_spec (wv_spec_to_array) subroutine in
the library of German A. Prieto.</p>
<p>It is very slow for large arrays so try with a small one (&lt; 5000 samples)
first, or adapt frac respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; numpy.ndarray;
The input signal</li>
<li><strong>delta</strong> &#8211; integer;
The input sampling interval</li>
<li><strong>time_bandwidth</strong> &#8211; float;
Time bandwith product</li>
<li><strong>number_of_tapers</strong> &#8211; int;
Number of tapers to use. If None the number will be automatically
determined</li>
<li><strong>smoothing_filter</strong> &#8211; string;
One of &#8216;boxcar&#8217;, &#8216;gauss&#8217; or just None</li>
<li><strong>filter_width</strong> &#8211; int;
Filter width in samples</li>
<li><strong>frequency_divider</strong> &#8211; int,
This method will always calculate all frequencies from 0..nyquist_freq.
This parameter allows the adjustment of the maximum frequency, so that
the frequencies range from 0..nyquist_freq/int(frequency_divider).
Defaults to 1.</li>
<li><strong>verbose</strong> &#8211; bool;
If True turn on verbose output</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.svg" alt="Logo"/>
    
  </a>
</p>





<p>
<iframe src="http://ghbtns.com/github-btn.html?user=krischer&repo=mtspec&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>




    

<p>
<a href="https://travis-ci.org/krischer/mtspec">
    <img
        alt="https://secure.travis-ci.org/krischer/mtspec.png?branch=master"
        src="https://secure.travis-ci.org/krischer/mtspec.png?branch=master"
    >
</a>
</p>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">mtspec API</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">mtspec Utilities</a></li>
</ul>


<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009-2015, Lion Krischer, Moritz Beyreuther.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.6.3</a>
      
      |
      <a href="_sources/multitaper.txt"
          rel="nofollow">Page source</a></li>
    </div>

    

    
  </body>
</html>